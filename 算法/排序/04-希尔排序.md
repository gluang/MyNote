<h2 align="center">希尔排序</h2>

**总结**：

使用步长对半**分组**，再对 2 个分组对应的元素进行比较（使用**直接插入排序**）。

**算法思想**：也称递减增量排序算法，实质上是一种 **分组插入** 方法。先将整个待排序的记录序列分割成为若干子序列分别进行 **直接插入排序**。

1. 分组：对于 `n` 个待排序的数列，取一个小于 `n` 的整数 `gap`（`gap` 被称为步长）将待排序元素分成若干个组子序列，所有距离为 `gap` 的倍数的记录放在同一个组中；
2. 排序：对各组内的元素进行直接插入排序。这一趟排序完成之后，每一个组的元素都是有序的；
3. 重复：然后减小 `gap` 的值，并重复执行上述的分组和排序；
4. 重复这样的操作，当 `gap=1` 时，整个数列就是有序的。

![](images/希尔排序.gif)

```cpp
void shell_sort(int *arr, int len)
{
    // >> 1：表示 / 2
    for (int gap = len >> 1; gap > 0; gap >>= 1)
    {
        // 共 gap 个组，对每一组都执行直接插入排序
        for (int i = gap; i < len; i++)
        {
            // i 和 j 相差 gap
            int j = i - gap;
            // 如果arr[j] < arr[j-gap]，则寻找arr[j]位置，并将后面数据的位置都后移
            if (arr[i] < arr[j])
            {
                int temp = arr[i];
                for (; j >= 0 && arr[j] > temp; j -= gap)
                    arr[j + gap] = arr[j];
                arr[j + gap] = temp;
            }
        }
    }
}
```

步骤：

```
原数组：{80,30,60,40,20,10,50,70}

gap = 4：
    分为 4 个组：{80, 20}, {30, 10}, {60, 50}, {40, 70}
    对应数列：{80, 30, 60, 40, 20, 10, 50, 70}
    对 4 个组分别进行排序：{20, 80}, {10, 30}, {50, 60}, {40, 70}
    对应数列：{20, 10, 50, 40, 80, 30, 60, 70}

gap = 2：
    分为 2 个组：{20, 50, 80, 60}, {10, 40, 30, 70}
    对应数列：{20, 10, 50, 40, 80, 30, 60, 70}
    注意：
        {20, 50, 80, 60} 实际上有 2 个有序的数列 {20, 80} 和 {50, 60} 组成
        {10, 40, 30, 70} 实际上有 2 个有序的数列 {10, 30} 和 {40, 70} 组成
    对 2 个组分别进行排序：{20, 50, 60, 80}, {10, 30, 40, 70}
    对应数列：{20, 10, 50, 30, 60, 40, 80, 70}

gap = 1：
    分为 1 个组：{20, 10, 50, 30, 60, 40, 80, 70}
    注意：{20, 10, 50, 30, 60, 40, 80, 70} 实际上有两个有序的数列 {20, 50, 60, 80} 和 {10, 30, 40, 70} 组成
    对 1 个组分别进行排序：{10, 20, 30, 40, 50, 60, 70, 80}
```
