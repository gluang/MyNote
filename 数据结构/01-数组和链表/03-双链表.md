<h1 align="center">ç›®å½•</h1>

* [1. çŸ¥è¯†ç‚¹](#1-çŸ¥è¯†ç‚¹)
    * [1.1. æ’å…¥](#11-æ’å…¥)
    * [1.2. åˆ é™¤](#12-åˆ é™¤)
    * [1.3. é¢˜ç›®ï¼šå‡¯æ’’å¯†ç ](#13-é¢˜ç›®å‡¯æ’’å¯†ç )
* [2. C++å®ç°](#2-cå®ç°)
    * [2.1. è‡ªå·±](#21-è‡ªå·±)
    * [2.2. å‚è€ƒ](#22-å‚è€ƒ)
* [3. Goå®ç°](#3-goå®ç°)
* [4. å‚è€ƒèµ„æ–™](#4-å‚è€ƒèµ„æ–™)

---

# 1. çŸ¥è¯†ç‚¹
å¯¹äºåŒå‘é“¾è¡¨çš„ç†è§£å°±ç›¸å½“ç®€å•ã€‚åŒå‘é“¾è¡¨å°±æ˜¯åœ¨å•é“¾è¡¨çš„åŸºç¡€ä¹‹ä¸Šï¼Œä¸ºæ¯ä¸€ä¸ªç»“ç‚¹å¢åŠ äº†å®ƒçš„å‰ç»§ç»“ç‚¹ã€‚åŒå‘é“¾è¡¨çš„å®šä¹‰å¦‚ä¸‹ï¼š

éœ€è¦æ˜ç™½ï¼š

* `p` æŒ‡å½“å‰èŠ‚ç‚¹
* `p->next` æŒ‡åä¸€ä¸ªèŠ‚ç‚¹
* `p->front` æŒ‡å‰ä¸€ä¸ªèŠ‚ç‚¹

```cpp
struct Node
{
	int val;
	Node *next;	// å‰é©±èŠ‚ç‚¹
	Node *prev; // åç»§èŠ‚ç‚¹
	Node(int data) : val(data), next(nullptr), prev(nullptr) { }
};
```

## 1.1. æ’å…¥
éœ€è¦ 2 ä¸ªæŒ‡é’ˆå¯¹è±¡ `p` å’Œ `p->next`ã€‚

```
p  =  p->next
 \\   //
  node
```

```cpp
// å…ˆè®¾ç½® node å¯¹è±¡
node->front = p;
node->next = p->next;
// å†ä»¥ p ä¸ºå¯¹è±¡è¿›è¡Œè¿æ¥
p->next = node;
p->next->front = node;
```

![](images/åŒå‘é“¾è¡¨_1.png)

## 1.2. åˆ é™¤
**åˆ é™¤**ï¼šp ä¸ºè¦åˆ é™¤ç‚¹

1. å…ˆæ›´æ¢ p çš„ front
2. å†æ¢ p çš„ next

```
p->front   p   p->next
```

```cpp
p->front->next = p->next;
p->next->front = p->front;
delete p;
```

![](images/åŒå‘é“¾è¡¨_2.png)


## 1.3. é¢˜ç›®ï¼šå‡¯æ’’å¯†ç 
é¢˜ç›®æè¿°ï¼š

è¦æ±‚å®ç°ç”¨æˆ·è¾“å…¥ä¸€ä¸ªæ•°ä½¿å¾— 26 ä¸ªå­—æ¯çš„æ’åˆ—å‘ç”Ÿå˜åŒ–ï¼Œä¾‹å¦‚ç”¨æˆ·è¾“å…¥ 3ï¼Œè¾“å‡ºç»“æœï¼š

```
DEFGHIJKLMNOPQRSTUVWXYZABC
```

åŒæ—¶éœ€è¦æ”¯æŒè´Ÿæ•°ï¼Œä¾‹å¦‚ç”¨æˆ·è¾“å…¥ -3ï¼Œè¾“å‡ºç»“æœï¼š

```
XYZABCDEFGHIJKLMNOPQRSTUVW
```

åŒå‘å¾ªç¯é“¾è¡¨åˆå§‹åŒ–æ“ä½œï¼ˆInitList()å‡½æ•°ï¼‰æ‰§è¡Œæµç¨‹ï¼š


![](images/åŒå‘é“¾è¡¨_3.png)

![](images/åŒå‘é“¾è¡¨_4.png)

![](images/åŒå‘é“¾è¡¨_5.png)

![](images/åŒå‘é“¾è¡¨_6.png)

![](images/åŒå‘é“¾è¡¨_7.png)

Caesar()å‡½æ•°çš„æ‰§è¡Œè¿‡ç¨‹ï¼š

![](images/åŒå‘é“¾è¡¨_8.png)

![](images/åŒå‘é“¾è¡¨_9.png)


```cpp
#include <stdio.h>
#include <stdlib.h>

#define OK 1
#define ERROR 0

typedef char ElemType;
typedef int Status;

typedef struct DaulNode
{
    ElemType data;
    struct DaulNode *prior;
    struct DaulNode *next;
}DaulNode, *DuLinkList;

Status InitList(DuLinkList *L)
{
    DaulNode *p, *q;
    int i;

    *L = (DuLinkList)malloc(sizeof(DaulNode));
    if(!(*L))
    {
        return ERROR;
    }

    (*L)->next = (*L)->prior = NULL;
    p = (*L);

    for( i = 0; i < 26; i++)
    {
        q = (DaulNode *)malloc(sizeof(DaulNode));
        if( !q )
            return ERROR;

        q->data = 'A'+i;
        q->prior = p;
        q->next = p->next;
        p->next = q;

        p = q;
    }

    p->next = (*L)->next;
    (*L)->next->prior = p;

    return OK;
}

void Caesar(DuLinkList *L, int i)
{
    if( i > 0 )
    {
        do
        {
            (*L) = (*L)->next;
        }while(--i);
        printf("%d", i);
    }

    if(i < 0)
    {
        (*L) = (*L)->next->prior;
        do
        {
            (*L) = (*L)->prior;
        }while( ++i );
    }

}

int main()
{
    DuLinkList L;
    int i, n;

    InitList(&L);

    printf("Please input n :");
    scanf("%d",&n);
    printf("\n");
    Caesar(&L, n);

    for( i=0; i < 26; i++)
    {
        L = L->next;
        printf("%c",L->data);
    }
}
```

# 2. C++å®ç°
## 2.1. è‡ªå·±
* ç»´æŠ¤äº†ä¸€ä¸ªå¤´èŠ‚ç‚¹ `head` å’Œå°¾èŠ‚ç‚¹ `tail` ä»¥åŠé•¿åº¦ `len`
* æŸ¥æ‰¾æ—¶æ€»éœ€è¦å…¨éƒ¨éå†ï¼Œä»å¤´åˆ°å°¾

```cpp
#ifndef _DOUBLE_LINK_H_
#define _DOUBLE_LINK_H_

#include <iostream>

class CList {
private:
    struct Node {
        int   val;
        Node *next;
        Node *prev;
        Node(int data)
            : val(data)
            , next(nullptr)
            , prev(nullptr) {
        }
    };

    Node *head; // å¤´èŠ‚ç‚¹
    Node *tail; // å°¾èŠ‚ç‚¹
    int   len;

public:
    // åˆ›å»ºåŒå‘é“¾è¡¨
    CList()
        : len(0)
        , head(new Node(0))
        , tail(head) {
    }

    ~CList() {
        clear();
    }

    void push_back(int val) {
        Node *temp = new Node(val);
        temp->next = nullptr;
        temp->prev = tail;

        tail->next = temp;
        tail       = temp;
        len++;
    }

    // 4 æ­¥åŸåˆ™
    void push_front(int val) {
        Node *temp = new Node(val);
        temp->next = head->next;
        temp->prev = head;

        head->next       = temp;
        temp->next->prev = temp;
        len++;
    }

    void pop_back() {
        Node *temp = tail;
        tail       = temp->prev;
        tail->next = nullptr;
        delete temp;
        len--;
    }

    // 3 æ­¥åŸåˆ™
    void pop_front() {
        Node *temp       = head->next;
        head->next       = temp->next;
        temp->next->prev = temp->prev;

        delete temp;
        len--;
    }

    // æ­£å‘éå†
    void forward_traversal() const {
        Node *p = head->next;
        while (p != nullptr) {
            std::cout << p->val << "  ";
            p = p->next;
        }
        std::cout << std::endl;
    }

    // é€†å‘éå†
    void reverse_traversal() const {
        Node *p = tail;
        while (p->prev != nullptr) {
            std::cout << p->val << "  ";
            p = p->prev;
        }
        std::cout << std::endl;
    }

    // å†’æ³¡æ’åº
    void bubble_sort() {
        // Node *p = new Node(0);
        // Node *q = new Node(0);
        Node *q = nullptr;
        int   temp;
        for (Node *p = head->next; p->next != nullptr; p = p->next) {
            for (q = p->next; q != nullptr; q = q->next) {
                if (q->val < p->val) {
                    temp   = q->val;
                    q->val = p->val;
                    p->val = temp;
                }
            }
        }
        
        // é‡æ–°æŸ¥æ‰¾ tail çš„ä½ç½®
        Node *point = head;
        while (point->next) {
            point = point->next;
        }
        tail = point;
    }

    // æ’å…¥æ’åº
    void insert_sort() {
        if (head->next == nullptr || head->next->next == nullptr) {
            return;
        }
        Node *p2         = head->next->next;
        Node *p1         = head;
        head->next->next = nullptr;
        while (p2) {
            Node *pN = p2->next;
            while (p1->next) {
                // å°çš„æ’åœ¨å‰é¢
                if (p2->val < p1->next->val) {
                    p2->next       = p1->next;
                    p2->prev       = p1;
                    p1->next->prev = p2;
                    p1->next       = p2;
                    break;
                }
                p1 = p1->next;
            }
            if (p1->next == nullptr) {
                // å¦‚æœæ²¡æ‰¾åˆ°å°å€¼ï¼Œåˆ™å°±æ˜¯å¤§å€¼ï¼Œæ’åœ¨åé¢
                p2->next = nullptr;
                // æ­¤æ—¶p1å·²ç»åœ¨å°¾éƒ¨äº†
                p2->prev = p1;
                p1->next = p2;
            }
            p2 = pN;
        }

        // é‡æ–°æŸ¥æ‰¾ tail çš„ä½ç½®
        Node *pt = head;
        while (pt->next) {
            pt = pt->next;
        }
        tail = pt;
    }

    // ä¿®æ”¹é“¾è¡¨ä¸­æŒ‡å®šä½ç½®çš„èŠ‚ç‚¹
    void update(int val, int position) {
        Node *p = head->next;
        if (position > len || position <= 0) {
            std::cout << "over stack !" << std::endl;
            return;
        }
        for (int i = 0; i < position - 1; i++) {
            p = p->next;
        }
        p->val = val;
    }

    // position ä»1å¼€å§‹
    void insert(int num, int position) {
        Node *p = head->next;
        if (position > len || position <= 0) {
            std::cout << "over stack !" << std::endl;
            return;
        }
        for (int i = 0; i < position - 1; i++) {
            p = p->next;
        }

        Node *temp    = new Node(num);
        temp->next    = p;
        temp->prev    = p->prev;
        p->prev->next = temp;
        p->prev       = temp;
        len++;
    }

    void clear() {
        Node *q = nullptr;
        Node *p = head->next;
        while (p != nullptr) {
            q = p;
            p = p->next;
            delete q;
        }
        p = nullptr;
        q = nullptr;
    }

    // åˆ é™¤æŒ‡å®šä½ç½®çš„èŠ‚ç‚¹
    void erase(int position) {
        Node *p = head->next;
        if (position > len || position <= 0) {
            std::cout << "over stack !" << std::endl;
            return;
        }
        for (int i = 0; i < position - 1; i++) {
            p = p->next;
        }
        p->prev->next = p->next;
        p->next->prev = p->prev;
        delete p;
        len--;
    }

    // æŸ¥æ‰¾æŒ‡å®šä½ç½®çš„èŠ‚ç‚¹
    int find(int position) const {
        Node *p = head->next;
        if (position > len || position <= 0) {
            std::cout << "over stack !" << std::endl;
            return 0;
        }
        for (int i = 0; i < position - 1; i++) {
            p = p->next;
        }
        return p->val;
    }
};

#endif // _DOUBLE_LINK_H_
```

```cpp
#include "include/clist.hpp"
#include <iostream>

int main() {
    CList l;
    l.push_back(35);
    l.push_back(30);
    l.push_back(32);
    l.push_front(4);
    l.push_front(5);
    l.pop_back();
    l.pop_front();
    l.forward_traversal();
    // 4  35  30

    std::cout << "æ’åº" << std::endl;
    //    l.bubble_sort();      //å†’æ³¡æ’åº
    l.insert_sort(); //æ’å…¥æ’åº
    l.forward_traversal();
    // 4  30  35

    std::cout << "æ’å…¥ï¼š" << std::endl;
    l.insert(55, 1);
    l.forward_traversal();
    // 55  4  30  35

    std::cout << "åˆ é™¤ï¼š" << std::endl;
    l.erase(1);
    l.forward_traversal();
    // 4  30  35

    std::cout << "åå‘éå†" << std::endl;
    l.reverse_traversal();
    // 35  30  4

    std::cout << "æ‰“å°ç¬¬ 2 ä¸ªç‚¹çš„æ•°æ®" << l.find(2) << std::endl;
    // 30

    return 0;
}
```

## 2.2. å‚è€ƒ
* åªç»´æŠ¤ä¸€ä¸ªå¤´èŠ‚ç‚¹ `head` å’Œé•¿åº¦ `count`

```cpp

#ifndef _DOUBLE_LINK_H_
#define _DOUBLE_LINK_H_

#include <iostream>

class DoubleLink {
private:
    struct DNode {
        int    val;
        DNode *prev;
        DNode *next;
        DNode(int t, DNode *pprev, DNode *pnext)
            : val(t)
            , prev(pprev)
            , next(pnext) {
        }
    };

    int    count;
    DNode *head;

public:
    DoubleLink()
        : count(0) {
        // åˆ›å»ºâ€œè¡¨å¤´â€ã€‚æ³¨æ„ï¼šè¡¨å¤´æ²¡æœ‰å­˜å‚¨æ•°æ®ï¼
        head       = new DNode(0, nullptr, nullptr);
        head->prev = head->next = head;
    }

    ~DoubleLink() {
        // åˆ é™¤æ‰€æœ‰çš„èŠ‚ç‚¹
        DNode *ptmp;
        DNode *pnode = head->next;
        while (pnode != head) {
            ptmp  = pnode;
            pnode = pnode->next;
            delete ptmp;
        }

        // åˆ é™¤"è¡¨å¤´"
        delete head;
        head = nullptr;
    }

    int size() const {
        return count;
    }

    bool empty() const {
        return count == 0 ? true : false;
    };

    // è·å–ç¬¬indexä½ç½®çš„èŠ‚ç‚¹çš„å€¼
    int get(int index) {
        return get_node(index)->val;
    }

    // è·å–ç¬¬1ä¸ªèŠ‚ç‚¹çš„å€¼
    int front() {
        return get_node(0)->val;
    }

    // è·å–æœ€åä¸€ä¸ªèŠ‚ç‚¹çš„å€¼
    int back() {
        return get_node(count - 1)->val;
    };

    // å°†èŠ‚ç‚¹æ’å…¥ç¬¬ä¸€ä¸ªèŠ‚ç‚¹å¤„
    void push_front(int val) {
        DNode *pnode     = new DNode(val, head, head->next);
        head->next->prev = pnode;
        head->next       = pnode;
        count++;
    }

    // å°†èŠ‚ç‚¹è¿½åŠ åˆ°é“¾è¡¨çš„æœ«å°¾
    void push_back(int val) {
        // ğŸ”¥ç‰¹åˆ«æ³¨æ„ï¼šé“¾è¡¨æœ€åä¸€ä¸ªnodeçš„nextæ˜¯æŒ‡å‘headï¼Œè€Œheadçš„prevå®é™…ä¸ŠæŒ‡å‘çš„æ˜¯é“¾è¡¨æœ€åä¸€ä¸ªnode
        // ğŸ”¥ å®é™…ä¸Šæœ‰å¾ªç¯é“¾è¡¨çš„æ„Ÿè§‰äº†
        DNode *pnode     = new DNode(val, head->prev, head);
        head->prev->next = pnode;
        head->prev       = pnode;
        count++;
    }

    void insert(int index, int val) {
        if (index == 0) {
            push_front(val);
        } else {
            DNode *pindex      = get_node(index);
            DNode *pnode       = new DNode(val, pindex->prev, pindex);
            pindex->prev->next = pnode;
            pindex->prev       = pnode;
            count++;
        }
    }

    // åˆ é™¤indexä½ç½®çš„èŠ‚ç‚¹
    void erase(int index) {
        DNode *pindex      = get_node(index);
        pindex->next->prev = pindex->prev;
        pindex->prev->next = pindex->next;
        delete pindex;
        count--;
    }

    // åˆ é™¤ç¬¬ä¸€ä¸ªèŠ‚ç‚¹
    void pop_front() {
        erase(0);
    }

    // åˆ é™¤æœ€åä¸€ä¸ªèŠ‚ç‚¹
    void pop_back() {
        erase(count - 1);
    }

private:
    // è·å–ç¬¬indexä½ç½®çš„èŠ‚ç‚¹
    DNode *get_node(int index) const {
        // åˆ¤æ–­å‚æ•°æœ‰æ•ˆæ€§
        if (index < 0 || index >= count) {
            std::cout << "get node failed! the index in out of bound!" << std::endl;
            return nullptr;
        }

        // æ­£å‘æŸ¥æ‰¾
        if (index <= count / 2) {
            int    i      = 0;
            DNode *pindex = head->next;
            while (i++ < index) {
                pindex = pindex->next;
            }

            return pindex;
        }

        // åå‘æŸ¥æ‰¾
        int    j       = 0;
        int    rindex  = count - index - 1;
        DNode *prindex = head->prev;
        while (j++ < rindex) {
            prindex = prindex->prev;
        }

        return prindex;
    }
};

#endif // _DOUBLE_LINK_H_
```

```cpp
#include "include/clist.hpp"
#include <iostream>

int main() {
    DoubleLink pdlink;

    pdlink.insert(0, 20);  // å°† 20 æ’å…¥åˆ°ç¬¬ä¸€ä¸ªä½ç½®
    pdlink.push_back(10);  // å°† 10 è¿½åŠ åˆ°é“¾è¡¨æœ«å°¾
    pdlink.push_front(30); // å°† 30 æ’å…¥åˆ°ç¬¬ä¸€ä¸ªä½ç½®

    std::cout << "empty()=" << (pdlink.empty() ? "true" : "false") << std::endl;
    // empty() = false
    std::cout << "size()=" << pdlink.size() << std::endl;
    // size() = 3

    for (int i = 0; i < pdlink.size(); i++)
        std::cout << "pdlink(" << i << ")=" << pdlink.get(i) << std::endl;
    // pdlink(0) = 30
    // pdlink(1) = 20
    // pdlink(2) = 10

    return 0;
}
```

# 3. Goå®ç°

```go
package main

import (
	"fmt"
)

// å®šä¹‰èŠ‚ç‚¹
type Node struct {
	Value 	int
	Prev	*Node
	Next 	*Node
}

// åˆå§‹åŒ–å¤´èŠ‚ç‚¹
var head = new(Node)

// æ·»åŠ èŠ‚ç‚¹
func addNode(t *Node, v int) int {
	if head == nil {
		t = &Node{v, nil, nil}
		head = t
		return 0
	}

	if v == t.Value {
		fmt.Println("èŠ‚ç‚¹å·²ç»å­˜åœ¨ï¼š", v)
		return -1
	}

	// å¦‚æœå½“å‰èŠ‚ç‚¹çš„ä¸‹ä¸€ä¸ªèŠ‚ç‚¹ä¸ºç©º
	if t.Next == nil {
		// ä¸å•é“¾è¡¨ä¸åŒçš„æ˜¯æ¯ä¸ªèŠ‚ç‚¹è¿˜è¦ç»´æŠ¤å‰é©±èŠ‚ç‚¹æŒ‡é’ˆ
		temp := t
		t.Next = &Node{v, temp, nil}
		return -2
	}

	// å¦‚æœå½“å‰èŠ‚ç‚¹çš„ä¸‹ä¸€ä¸ªèŠ‚ç‚¹ä¸ä¸ºç©ºï¼Œåˆ™ç»§ç»­éå†
	return addNode(t.Next, v)
}

func traverse(t *Node)  {
	if t == nil {
		fmt.Println("-> ç©ºé“¾è¡¨ï¼")
		return	
	}

	for t != nil {
		fmt.Printf("%d -> ", t.Value)
		t = t.Next
	}

	fmt.Println()
}

// æ–¹å‘éå†é“¾è¡¨
func reverse(t *Node)  {
	if t == nil {
		fmt.Println("-> ç©ºé“¾è¡¨ï¼")
		return	
	}

	// temp ä¸ºå°¾èŠ‚ç‚¹
	temp := t
	for t != nil {
		temp = t
		t = t.Next
	}

	for temp.Prev != nil {
		fmt.Printf("%d -> ", temp.Value)
		temp = temp.Prev
	}

	fmt.Printf("%d -> ", temp.Value)
	fmt.Println()
}


// è·å–é“¾è¡¨é•¿åº¦
func size(t *Node) int {
	if t == nil {
		fmt.Println("-> ç©ºé“¾è¡¨ï¼")
		return 0
	}

	n := 0
	for t != nil {
		n++
		t = t.Next
	}

	return n
}

// æŸ¥æ‰¾èŠ‚ç‚¹
func lookupNode(t *Node, v int) bool {
	if head == nil {
		return false
	}

	if v == t.Value {
		return true
	}

	// ç»ˆç‚¹
	if t.Next == nil {
		return false
	}

	return lookupNode(t.Next, v)
}

func main() {
	fmt.Println(head)
	head = nil	
	traverse(head)

	addNode(head, 1)
	traverse(head)

	addNode(head, 10)
	addNode(head, 5)
	addNode(head, 100)
	traverse(head)

	// æ·»åŠ å·²å­˜åœ¨èŠ‚ç‚¹
	addNode(head, 100)
	fmt.Println("é“¾è¡¨é•¿åº¦ï¼š", size(head))
	traverse(head)

	// åå‘éå†
	reverse(head)

	// æŸ¥æ‰¾å·²å­˜åœ¨èŠ‚ç‚¹
	if lookupNode(head, 5) {
		fmt.Println("è¯¥èŠ‚ç‚¹å·²å­˜åœ¨ï¼")
	} else {
		fmt.Println("è¯¥èŠ‚ç‚¹ä¸å­˜åœ¨ï¼")
	}
}
```

```
&{0 <nil> <nil>}
-> ç©ºé“¾è¡¨ï¼
1 -> 
1 -> 10 -> 5 -> 100 -> 
èŠ‚ç‚¹å·²ç»å­˜åœ¨ï¼š 100
é“¾è¡¨é•¿åº¦ï¼š 4
1 -> 10 -> 5 -> 100 -> 
100 -> 5 -> 10 -> 1 -> 
è¯¥èŠ‚ç‚¹å·²å­˜åœ¨ï¼
```

# 4. å‚è€ƒèµ„æ–™
* [é“¾å¼å­˜å‚¨ç»“æ„ä¹‹åŒå‘é“¾è¡¨ä¸è·³è¡¨](https://mp.weixin.qq.com/s/002qc9zj1h1yti6_Ui2MtQ)
* [çº¿æ€§è¡¨--æ•°ç»„ã€å•é“¾è¡¨ã€åŒé“¾è¡¨(C/C++/Java)](http://wangkuiwu.github.io/2013/01/01/dlink/)
